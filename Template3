<template>
  <el-button @click="func1()"></el-button>
  <div v-for="item in ref2" :key="item.id"> <!-- v-for实现循环一般都需要带上key，方便跟踪节点和排序 -->
    <!-- 内容 -->
  </div>

  <!-- 使用特殊的 $event 变量，将时间属性传递到script中进行处理 -->
  <button @click="func1('Form cannot be submitted yet.', $event)">
    Submit
  </button>
  <!-- 事件处理常用后缀 -->
  <!-- .stop：阻止冒泡（通俗讲就是阻止事件向上级DOM元素传递） -->
  <!-- .prevent：阻止默认事件的发生 -->
  <!-- .capture：捕获冒泡，即有冒泡发生时，有该修饰符的dom元素会先执行，如果有多个，从外到内依次执行，然后再按自然顺序执行触发的事件。 -->
  <!-- .self：将事件绑定到自身，只有自身才能触发，通常用于避免冒泡事件的影响 -->
  <!-- .once：设置事件只能触发一次，比如按钮的点击等。 -->
  <!-- .native：在父组件中给子组件绑定一个原生的事件，就将子组件变成了普通的HTML标签，不加'.native'事件是无法触发的。 -->
  <div @keyup.enter="xxx"></div> <!-- 按键事件触发 -->
  <div @keydown.alt="xxx"></div>

  <!-- title和key是该组件传递给子组件props的参数，使用:可以动态绑定，用于父→子参数传递 -->
  <!-- @abc是子组件$emit事件传递给该组件的，该组件使用method接收结果，用于子→父参数传递 -->
  <child title="xxx" :key="xxx" @abc="method"></child>

  <!-- 插槽定义 -->
  <slot name="xxx"></slot>
  <child>
    <!-- 传入插槽内容，v-slot:可以简写为#，xxx可以改为[xxx]动态名称 -->
    <template #xxx></template>
  </child>

  <div>
    <p>{{ computed1 }}</p>
  </div>
  <child :ref1="ref1" :reactive1="reactive1"></child>
</template>

<script setup>
import {
  computed,
  defineProps,
  defineEmits,
  nextTick,
  onBeforeMount,
  onBeforeUnmount,
  onMounted,
  onUnmounted,
  onUpdated,
  reactive,
  ref, watch
} from "vue";
import Child from "@/components/Child";

const ref1 = ref(0); // 响应式变量
const ref2 = ref({name: 'Tom', age: 15}); // 响应式变量
const reactive1 = reactive({value: 0}); // 只能用于对象类型
const func1 = function () {
  nextTick(() => {
    // 放入到nextTick的回调函数里能保证在下一次DOM刷新后再执行里面的内容
    // 多用于：1.页面还没初始化完成（created/mounted）；2.同步流程中改变元素但是无法同步获取，放到该方法里异步刷新DOM后再执行逻辑
    ref1.value += 1;
    reactive1.value += 1;
  })
}
const computed1 = computed(() => { // computed计算属性，用于响应式依赖发生变化时同步刷新该变量，常用于模板动态刷新
  return ref2.value.name ? 'Yes' : 'No'; //计算属性中使用 reverse() 和 sort() 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。
                                         // 请在调用这些方法之前创建一个原数组的副本：return [...numbers].reverse()
})
watch(                                  // 监听函数，在监听值发生变化时执行
    ref1,                                 // 可以监听ref/value/array等，value：() => {ref1.value}，array：[ref1, ref2]
    (newVal, oldVal) => {             // 监听ref会自动深度监听，监听value只有对象被替换时才会触发，可以手动加deep
      return newVal > oldVal;             // 监听最好不要放异步回调里，否则需要手动销毁：const a = watch();a();
    },
    {
      deep: true,
      immediate: true,
    },)

const props = defineProps({       // 用于接收父组件传入的数据
  value1: {
    type: Number,
    default: 1,
  },
  value2: {
    type: Function,
  },
});

const emits = defineEmits(['emit1', 'emit2']);   // 用于定义发送给父组件的事件
const emitFunc = function () {
  emits('emit1', 'res')                          // 发送事件
}
emitFunc();

const asyncFunc = async function () { // 声明是异步方法，注意：async方法返回的是promise对象，不能直接拿来比较！得用then或者await接受结果
  let i = await asyncFunc(); // await能让异步方法等待，拿到结果再继续流程
  if (i === 1) {
    console.log("相等"); // 1
  } else {
    console.log("不相等");
  }
  return i;
};

onBeforeMount(() => {
}) // 注册一个钩子，在组件被挂载之前被调用。
onMounted(() => {
}) // 注册一个回调函数，在组件挂载完成后执行。
onUpdated(() => {
}) // 注册一个回调函数，在组件因为响应式状态变更而更新其 DOM 树之后调用。
onBeforeUnmount(() => {
}) // 注册一个钩子，在组件实例被卸载之前调用。
onUnmounted(() => {
}) // 注册一个回调函数，在组件实例被卸载之后调用。
</script>

<!-- scoped，只能在该vue文件范围内进行使用，避免污染外部样式 -->
<style scoped></style>
<!-- css 可以使用外部引入的方式，@默认为src目录，~@不需要加后缀格式，@需要加后缀格式 -->
<!-- scss有层级关系，跟平铺的css样式不同，同样可以限制样式范围避免污染 -->
<style lang="scss">
import '@/xxx/xxx.scss';
</style>
